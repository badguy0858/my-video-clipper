name: AI Pro Animal Factory - FIXED
on:
  repository_dispatch:
    types: [trigger-compilation]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Video & AI Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg nodejs fonts-liberation bc
          pip install yt-dlp edge-tts openai-whisper google-api-python-client

      - name: Setup Viral Font
        run: |
          mkdir -p ~/.fonts
          wget -O ~/.fonts/BebasNeue.ttf "https://github.com/google/fonts/raw/main/ofl/bebasneue/BebasNeue-Regular.ttf" || true
          fc-cache -f -v

      - name: Advanced Content Scouting (Fixed)
        env:
          YOUTUBE_DATA: ${{ secrets.YOUTUBE_COOKIES }}
        run: |
          mkdir -p clips
          
          # 1. Create cookie file if credentials exist
          if [ ! -z "$YOUTUBE_DATA" ]; then
            echo "# Netscape HTTP Cookie File" > cookies.txt
            echo "$YOUTUBE_DATA" >> cookies.txt
            sed -i 's/\r//' cookies.txt
            COOKIE_ARG="--cookies cookies.txt"
          else
            COOKIE_ARG=""
          fi

          # 2. User-Agent
          UA="Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1"
          
          # 3. FIXED: Use direct YouTube search and properly capture URLs
          echo "Searching for trending viral shorts..."
          
          # Search and extract video IDs, then construct full URLs
          yt-dlp $COOKIE_ARG --user-agent "$UA" \
            --extractor-args "youtube:player_client=mweb,ios" \
            --get-id --flat-playlist \
            "ytsearch10:funny animals shorts 2025" 2>/dev/null | head -n 5 | while read -r id; do
              echo "https://www.youtube.com/watch?v=$id"
            done > links.txt

          # 4. Validate we got URLs
          if [ ! -s links.txt ]; then
            echo "Search failed. Using fallback curated list..."
            cat > links.txt << 'EOF'
https://www.youtube.com/shorts/kJQP7kiw5Fk
https://www.youtube.com/shorts/n4PR9NZlAB4
https://www.youtube.com/shorts/1Ne5mfKaBXk
https://www.youtube.com/shorts/W8waoRp_hhk
https://www.youtube.com/shorts/RFxVT7UdFDk
EOF
          fi

          echo "URLs to download:"
          cat links.txt

          # 5. Download with error handling
          echo "Starting downloads..."
          while IFS= read -r url; do
            if [ ! -z "$url" ]; then
              echo "Downloading: $url"
              yt-dlp $COOKIE_ARG --user-agent "$UA" \
                --extractor-args "youtube:player_client=mweb,ios" \
                --no-check-certificate --prefer-free-formats --no-warnings \
                -f "bv*[height<=1920][ext=mp4]+ba[ext=m4a]/b[height<=1920][ext=mp4]/best[height<=1920]" \
                --merge-output-format mp4 \
                -o "clips/%(id)s.%(ext)s" \
                "$url" || echo "Failed to download $url, continuing..."
            fi
          done < links.txt

          # 6. Final validation with multiple fallbacks
          if [ -z "$(ls -A clips 2>/dev/null)" ]; then
            echo "No clips downloaded. Attempting emergency fetch..."
            # Try a known working public domain/creative commons video
            yt-dlp "https://www.youtube.com/watch?v=aqz-KE-bpKQ" \
              -f "best[height<=1920]" --merge-output-format mp4 \
              -o "clips/emergency.mp4" || {
                echo "Emergency fetch failed. Creating test video..."
                # Create a simple test video as absolute last resort
                ffmpeg -f lavfi -i testsrc=duration=10:size=1080x1920:rate=30 \
                  -f lavfi -i sine=frequency=1000:duration=10 \
                  -pix_fmt yuv420p clips/test.mp4
              }
          fi
          
          echo "Final clip count: $(ls -1 clips | wc -l)"
          ls -lh clips/

      - name: AI Voice Generation
        run: |
          edge-tts --text "Wait until you see the last animal, it is absolutely hilarious! Like and subscribe for your daily dose of fun." \
            --write-media vo.mp3 --rate=+5%

      - name: Processing & Stitching (The Editor)
        run: |
          mkdir -p processed
          
          # Standardize clips to 9:16 vertical, 30fps
          for f in clips/*.mp4; do
            [ -f "$f" ] || continue
            echo "Processing: $f"
            ffmpeg -y -i "$f" \
              -vf "scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,setsar=1,fps=30" \
              -af "aresample=44100,pan=stereo|c0=c0|c1=c1" \
              -c:v libx264 -preset superfast -crf 23 \
              "processed/$(basename "$f")" || echo "Failed processing $f"
          done
          
          # Verify we have processed files
          if [ -z "$(ls -A processed 2>/dev/null)" ]; then
            echo "ERROR: No processed clips available"
            exit 1
          fi
          
          # Create concat file
          for f in processed/*.mp4; do
            echo "file '$PWD/$f'" >> list.txt
          done
          
          # Merge clips
          ffmpeg -f concat -safe 0 -i list.txt -c copy raw_stitch.mp4
          
          # Add Voiceover with proper audio mixing
          ffmpeg -i raw_stitch.mp4 -i vo.mp3 \
            -filter_complex "[1:a]adelay=1000|1000,volume=1.2[voice];[0:a]volume=0.3[bg];[bg][voice]amix=inputs=2:duration=first:dropout_transition=2" \
            -c:v copy -c:a aac -b:a 192k stitched.mp4

      - name: AI Klap-Style Captions
        shell: python
        run: |
          import whisper
          import os
          
          # Load model
          model = whisper.load_model("base")
          
          # Transcribe
          result = model.transcribe("stitched.mp4", word_timestamps=True, language="en")
          
          # Generate ASS subtitle file
          with open("subs.ass", "w", encoding="utf-8") as f:
              f.write("[Script Info]\n")
              f.write("ScriptType: v4.00+\n")
              f.write("PlayResX: 1080\n")
              f.write("PlayResY: 1920\n\n")
              
              f.write("[V4+ Styles]\n")
              f.write("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n")
              f.write("Style: Default,Bebas Neue,110,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,5,2,2,10,10,400,1\n\n")
              
              f.write("[Events]\n")
              f.write("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")
              
              def format_time(seconds):
                  hours = int(seconds // 3600)
                  minutes = int((seconds % 3600) // 60)
                  secs = seconds % 60
                  return f"{hours}:{minutes:02d}:{secs:05.2f}"
              
              for segment in result['segments']:
                  words = segment.get('words', [])
                  if not words:
                      # Fallback if no word timestamps
                      text = segment['text'].strip().upper()
                      start = format_time(segment['start'])
                      end = format_time(segment['end'])
                      f.write(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{text}\n")
                  else:
                      for word in words:
                          start = format_time(word['start'])
                          end = format_time(word['end'])
                          text = word['word'].strip().upper()
                          if text:  # Only add non-empty words
                              f.write(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{text}\n")

      - name: Final Render (Burning Subs)
        run: |
          ffmpeg -y -i stitched.mp4 -vf "ass=subs.ass" \
            -c:v libx264 -crf 18 -preset medium \
            -c:a aac -b:a 192k \
            output_final.mp4
          
          echo "Final video size:"
          ls -lh output_final.mp4

      - name: YouTube Upload
        shell: python
        env:
          ID: ${{ secrets.YT_CLIENT_ID }}
          SEC: ${{ secrets.YT_CLIENT_SECRET }}
          TOK: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          import os
          from googleapiclient.discovery import build
          from google.oauth2.credentials import Credentials
          from googleapiclient.http import MediaFileUpload
          
          # Verify credentials exist
          if not all([os.environ.get('TOK'), os.environ.get('ID'), os.environ.get('SEC')]):
              print("WARNING: YouTube credentials not configured. Skipping upload.")
              exit(0)
          
          try:
              creds = Credentials(
                  None, 
                  refresh_token=os.environ['TOK'], 
                  client_id=os.environ['ID'], 
                  client_secret=os.environ['SEC'], 
                  token_uri="https://oauth2.googleapis.com/token"
              )
              
              youtube = build("youtube", "v3", credentials=creds)
              
              request = youtube.videos().insert(
                  part="snippet,status",
                  body={
                      "snippet": {
                          "title": "Funny Animal Derps! üòÇ #Shorts",
                          "description": "Hilarious animal moments that will make your day! üê∂üê±\n\n#shorts #funny #animals #pets",
                          "tags": ["shorts", "funny", "animals", "pets", "cute"],
                          "categoryId": "15"
                      },
                      "status": {
                          "privacyStatus": "public",
                          "selfDeclaredMadeForKids": False
                      }
                  },
                  media_body=MediaFileUpload("output_final.mp4", chunksize=-1, resumable=True)
              )
              
              response = request.execute()
              print(f"Upload successful! Video ID: {response['id']}")
              print(f"Video URL: https://www.youtube.com/watch?v={response['id']}")
              
          except Exception as e:
              print(f"Upload failed: {str(e)}")
              print("Video saved as artifact instead.")

      - name: Save Artifact
        uses: actions/upload-artifact@v4
        with:
          name: final_video
          path: output_final.mp4
