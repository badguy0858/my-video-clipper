name: Ultimate AI Multi-Niche Clipper
on:
  repository_dispatch:
    types: [trigger-podcast]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Install AI & Pro Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg bc fonts-liberation
          pip install gdown openai-whisper google-api-python-client google-auth-oauthlib yt-dlp

      - name: Download Bebas Neue Font
        run: |
          mkdir -p ~/.fonts
          wget -q -O ~/.fonts/BebasNeue.ttf "https://raw.githubusercontent.com/google/fonts/main/ofl/bebasneue/BebasNeue-Regular.ttf"
          fc-cache -f -v

      - name: Download Assets
        run: |
          # 1. Download main video from Drive
          gdown --fuzzy "${{ github.event.client_payload.file_id }}" -O raw_input.mp4
          
          # 2. Download Satisfying Gameplay from YouTube (The link you provided)
          # We download only 2 minutes to save time
          yt-dlp -f "bestvideo[height<=1080][ext=mp4]" --downloader ffmpeg --downloader-args "ffmpeg:-t 120" "https://www.youtube.com/watch?v=n-P_V0vVd7E" -o satisfying.mp4

      - name: AI Smart Random Cut
        run: |
          DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 raw_input.mp4)
          DUR_INT=$(printf "%.0f" $DURATION)
          # Pick a random spot, but ensure we have 60s left
          MAX_START=$(($DUR_INT - 65))
          if [ "$MAX_START" -lt "1" ]; then START_TIME=0; else START_TIME=$(shuf -i 5-$MAX_START -n 1); fi
          ffmpeg -y -ss $START_TIME -t 58 -i raw_input.mp4 -c:v libx264 -crf 18 -c:a aac input_clip.mp4

      - name: AI Transcription & Content Generator
        shell: python
        run: |
          import whisper
          import re
          from collections import Counter

          # 1. AI Analysis
          model = whisper.load_model("base")
          result = model.transcribe("input_clip.mp4", word_timestamps=True)
          full_text = result['text'].upper()

          # 2. GENERATE 3-WORD TITLE
          # Finds the most important "Power Words" in your clip
          boring = ["THE", "AND", "YOU", "THAT", "THIS", "WITH", "FOR", "WAS", "HAVE", "THEIR", "WHAT"]
          words = [w for w in re.findall(r'\w+', full_text) if w not in boring and len(w) > 3]
          most_common = [word for word, count in Counter(words).most_common(3)]
          if len(most_common) < 3: most_common = ["INSANE", "VIRAL", "MOMENT"]
          ai_title = " ".join(most_common)
          
          # 3. GENERATE DESCRIPTION
          niche = "${{ github.event.client_payload.channel_type }}"
          ai_desc = f"{ai_title} ðŸ˜±\n\nAutomated by AI.\n\n#Shorts #{niche} #MrBeast #Podcast #Viral"

          with open("ai_content.txt", "w") as f:
              f.write(f"{ai_title}\n{ai_desc}")

          # 4. KLAP-STYLE CAPTION GENERATOR
          # Word-level highlighting (White text, Yellow active word)
          with open("klap_subs.ass", "w", encoding="utf-8") as f:
              margin = 480 if niche == "podcast" else 280
              f.write(f"[Script Info]\nScriptType: v4.00+\nPlayResX: 1080\nPlayResY: 1920\n\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, OutlineColour, BorderStyle, Outline, Alignment, MarginV\nStyle: Default,Bebas Neue,95,&H00FFFFFF,&H00000000,1,4,2,{margin}\n\n[Events]\nFormat: Layer, Start, End, Style, Text\n")
              for segment in result['segments']:
                  words = segment.get('words', [])
                  for i, w in enumerate(words):
                      ts = lambda s: f"{int(s//3600)}:{int((s%3600)//60):02d}:{s%60:05.2f}"
                      current = w['word'].strip().upper()
                      # Only the CURRENT word is Yellow (&H00FFFF)
                      f.write(f"Dialogue: 0,{ts(w['start'])},{ts(w['end'])},Default,,0,0,0,,{{\\c&H00FFFF}}{current}{{\\r}}\n")

      - name: Final Pro Render
        run: |
          CHANNEL="${{ github.event.client_payload.channel_type }}"
          if [ "$CHANNEL" = "podcast" ]; then
            # PODCAST STYLE: Half Screen Split
            ffmpeg -y -i input_clip.mp4 -i satisfying.mp4 -filter_complex "[0:v]scale=1080:960:force_original_aspect_ratio=increase,crop=1080:960[top];[1:v]scale=1080:960:force_original_aspect_ratio=increase,crop=1080:960[bottom];[top][bottom]vstack=inputs=2,ass=klap_subs.ass" -map 0:a -c:v libx264 -crf 18 -t 58 output.mp4
          else
            # MRBEAST STYLE: Full Vertical Crop
            ffmpeg -y -i input_clip.mp4 -vf "crop=ih*(9/16):ih,scale=1080:1920,ass=klap_subs.ass" -c:v libx264 -crf 18 -t 58 output.mp4
          fi

      - name: Post to YouTube
        shell: python
        env:
          ID: ${{ secrets.YT_CLIENT_ID }}
          SEC: ${{ secrets.YT_CLIENT_SECRET }}
          TOK: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          import os
          from googleapiclient.discovery import build
          from google.oauth2.credentials import Credentials
          from googleapiclient.http import MediaFileUpload

          with open("ai_content.txt", "r") as f:
              lines = f.readlines()
              yt_title = lines[0].strip()
              yt_desc = "".join(lines[1:])

          creds = Credentials(None, refresh_token=os.environ['TOK'], client_id=os.environ['ID'], client_secret=os.environ['SEC'], token_uri="https://oauth2.googleapis.com/token")
          youtube = build("youtube", "v3", credentials=creds)
          youtube.videos().insert(
              part="snippet,status",
              body={"snippet": {"title": yt_title, "description": yt_desc, "categoryId": "24"}, "status": {"privacyStatus": "public"}},
              media_body=MediaFileUpload("output.mp4", chunksize=-1, resumable=True)
          ).execute()

      - name: Notify n8n
        run: |
          curl -L -X POST "${{ github.event.client_payload.n8n_url }}" \
          -H "Content-Type: application/json" \
          -d '{"status": "success", "run_id": "${{ github.run_id }}"}'

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: final-viral-video
          path: output.mp4
